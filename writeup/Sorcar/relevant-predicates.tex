% !Tex root=main.tex

%---------- Computing relevant predicates ----------
\subsubsection{Computing Relevant Predicates}

In the following, we develop \emph{four} different implementations of the function \RelevantPredicates. %, named \RelevantPredicatesMax, \RelevantPredicatesFirst, \RelevantPredicatesMin, and \RelevantPredicatesGreedy.
All of these functions share the property that the search for relevant predicates is limited to the set $X \setminus R$ because only predicates in this set can help making $X \cap R$ consistent with negative and Horn counterexamples (cf.\ Line~\ref{sorcar:line:loop-head} of Algorithm~\ref{alg:sorcar}).
Moreover, recall that we define a predicate to be relevant if it evaluates to \textit{false} on some negative counterexample or on a program configuration appearing on the left-hand-side of a Horn counterexample.
Intuitively, these are predicates in $\mathcal P$ that have shown some relevancy in the sense that they can be used to establish consistency with the Horn-ICE sample.


%---------- Relevant Predicates Max ----------
\paragraph*{\protect{\RelevantPredicatesMax}}
The function \RelevantPredicatesMax, shown as Algorithm~\ref{alg:relevant-predicates-max} in Appendix~\ref{app:relevant-predicates-max}, computes the maximal set of relevant predicates from $X \setminus R$ with respect to the negative counterexamples in $N$ and the Horn counterexamples in $H$.
To this end, it accumulates all predicates that evaluate to \textit{false} on a negative counterexample in $N$ or on a program configuration appearing on the left-hand-side of a Horn counterexample in $H$.
The resulting set $R'$ can be large, but $X \cap R'$ is guaranteed to be consistent with $N$ and $H$ (because each negative counterexample and each program configuration on the left-hand-side of a Horn counterexample violates at least one predicates in $R'$, the latter causing each Horn counterexample to be violated).
Since $X \cap R$ was neither consistent with $N$ nor with $H$, and since $R'\subseteq X \setminus R$, it follows that $R'$ must contain at least one relevant predicate not in $R$, thus satisfying the requirement of \RelevantPredicates.
Finally, the runtime of \RelevantPredicatesMax is in $\mathcal O(|\mathcal P| \cdot |\mathcal S|)$ since $X \setminus R \subseteq \mathcal P$, $N \subseteq S_-$, and $H \subseteq S_H$.


%---------- Relevant Predicates First ----------
\paragraph*{\protect{\RelevantPredicatesFirst}}
The function \RelevantPredicatesFirst is shown as Algorithm~\ref{alg:relevant-predicates-first} in Appendix~\ref{app:relevant-predicates-first}.
Its goal is to select a smaller set of relevant predicates than \RelevantPredicatesMax, while giving the user some control over which predicates to choose.
More precisely, \RelevantPredicatesFirst selects for each negative counterexample and each Horn counterexample only one relevant predicate $p \in X \setminus R$.
The exact choice is determined by a total ordering $<_\mathcal P$ over the predicates, which reflects a preference among predicates and which we assume to be a~priori given by the user.
Using the same arguments as for the function \RelevantPredicatesMax, it is not hard to verify that the resulting set $R'$ contains at least one additional relevant predicate not in $R$ and that $X \cap R'$ is consistent with $N$ and $H$.
Moreover, $R'$ clearly contains only a subset of the predicates returned by \RelevantPredicatesMax.
Again, the runtime is in $\mathcal O(|\mathcal P| \cdot |\mathcal S|)$.


%---------- Relevant Predicates Min ----------
\paragraph*{\protect{\RelevantPredicatesMin}}
The function \RelevantPredicatesMin, shown as Algorithm~\ref{alg:relevant-predicates-min} in Appendix~\ref{app:relevant-predicates-min}, takes the idea of \RelevantPredicatesFirst one step further and computes a (not necessarily unique) \emph{minimum} set of relevant predicates with respect to $N$ and $H$.
It does so by means of a reduction to a well-known optimization problem called \emph{minimum hitting set}~\cite{DBLP:conf/coco/Karp72}.
For a collection $\{ A_1, \ldots, A_\ell \}$ of finite sets $A_i$, a set $B$ is a \emph{hitting set} if $B \cap A_i$ for all $i \in \{ 1, \ldots, n \}$, and the minimum hitting set problem asks to compute a hitting set of minimum cardinality.
%\kern-.06em\footnote{Together with a straightforward algorithm that guesses a minimal set of relevant predicates, } (thereby showing that the former problem is also NP-complete).
In the first step of the reduction, the function \RelevantPredicatesMin constructs for each negative counterexample $c \in N$ the set $A_c$ of all predicates $p \in X \setminus R$ violating $c$
%$A_c \coloneqq \{ p \in X \setminus R \mid c \not\models p \}$
and for each Horn counterexample $(L, c) \in H$ the set $A_{(L, c)}$ of all predicates $p \in X \setminus R$ violating some program configuration $c'\in L$.
%$A_{(L, c)} \coloneqq \{ p \in X \setminus R \mid \exists c' \in L \colon c' \not\models p \}$.
In a second step, it uses an exact algorithm (e.g., a SAT solver) to find a minimum hitting set $R'$ for the problem instance $Q \coloneqq \{ A_c \mid c \in N \} \cup \{ A_{(L, c)} \mid (L, c) \in H \}$.
By construction of the sets $A_c$ and $A_{(L, c)}$, the resulting minimum hitting set $R'$ then is a minimum set of relevant predicates guaranteeing that $X \cap R'$ is consistent with $N$ and $H$.
Moreover, $R'$ contains at least one relevant predicate not in $R$.
However, the downside of approach is 
that it is not a polynomial time algorithm as it requires a SAT solver.
%its exponential runtime in $2^{\mathcal O(|\mathcal P| \cdot |\mathcal S|)}$. % (unless $\text{P} = \text{NP}$).


%---------- Relevant Predicates Min ----------
\paragraph*{\protect{\RelevantPredicatesGreedy}}
The key idea underlying the function \texttt{Relevant-} \texttt{Predicates-Greedy}, which is shown as Algorithm~\ref{alg:relevant-predicates-greedy} in Appendix~\ref{app:relevant-predicates-greedy}, is to replace the exact computation of a minimum hitting set with a polynomial-time approximation algorithm.
More precisely, \RelevantPredicatesGreedy implements a straightforward greedy heuristic that successively chooses predicates $p \in X \setminus R$ that have the largest number of a non-empty intersections with  sets in $Q$.
This heuristic is essentially the dual of the well-known greedy algorithm for the minimum set cover problem~\cite{DBLP:journals/mor/Chvatal79} and guarantees to find a solution that is at most logarithmically larger than the optimal one.
Apart from being an approximation of the minimal set, choosing relevant predicates greedily based on the \emph{number} of sets it hits also has a statistical bias (choosing predicates more commonly occurring in the sets). 
Otherwise, except for a runtime in $\mathcal O(|\mathcal P| \cdot |\mathcal S|^2)$ and an approximation factor of $\log{|\mathcal S|}$, \RelevantPredicatesGreedy shares the same properties as the function \RelevantPredicatesMin.
